## 做了啥
logging部分见logging.h
### 基础部分
使用bazel进行构建和测试
实现了异步日志
实现了reactor模式的网络框架，非阻塞多路复用。
FixedBuffer中用使用array代替数组，类型安全。
单例模式
使用EmptyLogStream实现了日志级别，而不是#define LOG_INFO if xxx。更不安全。我的方案是调用<<运算符时，如果优先级没到设定的级别，就返回一个EmptyLogStream对象，它对输入什么也不做。但是这样的话，Logger对象内部的栈区的Buffer就很难搞，相当于白白申请了一堆空间没用。但时间上并没有多多少。而且去掉了奇怪的宏里带if又不带括号。
全面使用智能指针代替new，增强内存安全性


### 网络部分
实现buffer。由于系统调用的开销，一方面希望，每次调用尽可能多的读写；另一方面由于并发数很大，不能留太大的buffer空间。

muduo用了自己实现的线程类，我们用c++11标准的。
p5 线程安全的原则：
* 不要在构造函数中注册任何回调。
* 不要在构造函数中把this传给别的线程
关键是因为此时构造还没完成，别的线程可能会访问到半成品对象，产生未定义行为。

用shared_ptr管理对象，使得它能安全地析构。

## 杂项
既可以在函数声明中，也可以在函数定义中声明缺省参数，但不能既在函数声明中又在函数定义中同时声明缺省参数。因此，将定义或声明中的任一个缺省参数删除即可。

vscode在c++扩展中指定c++版本
bazel在WORKSPACE同级目录下的.bazelrc中写入build --cxxopt='-std=c++17'指定c++版本

__thread是线程的变量，但是不会自动初始化。也就是说，不支持类类型，只支持基本数据类型。
thread_local是c++11标准，会在线程创建和结束时调用构造函数和析构函数。

临时对象的生命周期在表达式结束时就到头了，就会被析构。比如A（），在这一行结束就析构了。
如果临时对象被赋值给了引用，就会延长到这个引用的生命周期结束。比如 const A& a = A()，在a所在的作用域结束时被析构

在构造函数中启动线程是不安全的。可能访问到还没初始化的成员，或者子类成员（定义了虚函数时）。

mutex是最基本的互斥原语。
lock_guard实现了构造时加锁，析构时解锁。不能拷贝和移动。
unique_lock在lock_guard的基础上还有移动构造函数，也支持手动加锁解锁，所以能和条件变量一起用。
条件变量一定要配合锁，因为由于线程调度，如果没锁，可能虚假唤醒。

基类析构函数一定要virtual.不用virtual就不会触发动态绑定,基类指针指向的子类在析构时就不会调用它自己的析构函数了.

与muduo的区别
用c++17的string_view代替muduo自己实现的StringPiece

linux下可以用io_uring实现真正的异步编程。
muduo基于io多路复用，算是非阻塞的同步网络框架。非阻塞就是说检查IO是否就绪时，如果没就绪，也不会阻塞，而是直接返回。实际上io多路复用就是同时检查一堆IO接口是否就绪，把就绪的哪些返回。同步就是说，在发现IO就绪以后，从内核读数据到用户态的过程是阻塞的，就是从调用read开始，用户进程要等待它读完。和它对应的异步指的就是调用read后直接返回，由操作系统完成把数据read到用户空间，然后通知用户进程handle。

遇到的问题：
epoller实现之后，在eventloop初始化时忘记初始化它了。gdb调试发现了问题。发现读到epoller的字段channels_时报段错误，发现epoller没初始化。